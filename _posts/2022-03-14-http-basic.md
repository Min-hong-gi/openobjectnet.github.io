---
title:  "HTTP 웹 기본 지식 정리"
search: false
categories: 
  - HTTP
toc: true  
tags:
  - HTTP
author: 오유민 
---

# Intro
안녕하세요 오유민 사원입니다. 

#HTTP 웹 기본지식 정리 

##목차
 1. 인터넷 네트워크  
    - IP  
    - TCP  
    - UDP  
    - 포트  
    - DNS
2. 웹브라우저 요청 흐름  
3. HTTP
    - 클라이언트 서버 구조  
    - 무상태 프로토콜  
    - 비연결성  
    - HTTP 메시지
4. HTTP 메소드 종류
5. HTTP 메소드 속성
    - 안전  
    - 멱등  
    - 캐시 가능
6. HTTP API 설계
7. HTTP 상태 코드
    - 2xx  
    - 3xx  
    - 4xx  
    - 5xx
8. HTTP 헤더
    - 일반 헤더   
        + 쿠키
    - 캐시와 조건부 요청 헤더  
        + 캐시


<br>

## 인터넷 네트워크
<hr>

### IP
인터넷 통신은 클라이언트와 서버사이에 많은 노드로 연결된 인터넷들을 거치며 이루어진다.  
노드사이에서 통신을 하기위해 IP주소를 이용한다.  
> 통신단위는 패킷이고  
> 출발 IP | 도착 IP | 메시지 로 이루어져 있다.  
비연결성, 비신뢰성, 프로그램 구분 불가등의 한계가 있다.  
+ 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능이어도 패킷을 전송  
+ 비신뢰성 : 패킷이 중간에 사라지거나 순서를 보장하지 않음
+ 프로그램 구분 : 같은 IP를 사용하는 서버에서 통신하는 어플리케이션이 둘 이상일 때 구분할 수 없음  
<br>

### TCP
IP만 사용했을 때의 비신뢰성, 비연결성, 프로그램 구분 불가의 한계를 극복하기 위해 사용한다.  
> IP패킷에 출발지 포트, 목적지 포트, 전송제어, 순서, 검증정보들이 메시지에 추가되어 전송된다.  
> 연결 지향인 3-way handshake를 한다.  
> 데이터를 전송하고 전송받았다는 메시지를 받아 확인이 가능하다.  
> 패킷의 순서를 보장한다.  

+ 3-way handshake

<img src="https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAxNzAzMTZfMjEw%2FMDAxNDg5NjIzMTQzOTcx.bytRbx15QwZBC6SqKyETeHO7t43FsHFJCH0yP7HwQe0g.3HK0sKSxblh1QmHFWsedZ3mIQyOl72flKRssBpeKgbkg.PNG.rjsdud13%2Fimage.png&type=a340">

클라이언트와 서버가 연결되었음을 학인하고 데이터를 전송한다.  
<br>

### UDP
TCP와 다르게 3-way handshake, 데이터 전달 보증, 순서보장을 하지 않는 대신 단순하고 빠르다.
> IP와 거의 같고, 포트정보, 체크섬(메시지가 맞는지 간단 검증)정도만 추가되었다. 
>주로 TCP를 기본으로 사용하고 UDP를 어플리케이션에서 추가작업하여 같이 사용한다. 

<br>

### 포트
하나의 IP에서 여러 어플리케이션을 사용할 수 있도록 구분하기위해 사용한다.
> TCP/IP 패킷 : 출발 IP, port | 목적 IP, port | 메시지  

<br>

### DNS
IP는 외우기 어렵고 변경될 수 있기 때문에 도메인을 사용하여 접속한다. 
> 클라이언트에서 도메인이름으로 검색 -> DNS서버에서 도메인에 해당하는 IP응답 -> 클라이언트에서 IP로 다시 접속  

<br>

## 웹브라우저 요청 흐름
- url의 호스트와 포트정보로 DNS서버에서 조회하여 http요청 메시지를 생성한다.  
 ex)
  > GET /search?q=hello&hl=ko HTTP/1.1  
    Host: www.google.com         

- TCP/IP 계층에 3-way handshake로 전달한 뒤 TCP/IP계층에서 IP패킷으로 한번 더 감싸서 메시지를 전달한다.
- 패킷을 받아서 메시지를 파싱한 후, http응답 메시지를 전송한다.  
 ex)  
  > accept-ch: Sec-CH-UA-Platform-Version  
accept-ch: Sec-CH-UA-Full-Version  
accept-ch: Sec-CH-UA-Arch  
accept-ch: Sec-CH-UA-Model  
accept-ch: Sec-CH-UA-Bitness  
cache-control: private  
content-encoding: br  
content-length: 123238  
content-type: text/html; charset=UTF-8   
<br>

## HTTP

### 클라이언트 서버 구조
> 클라이언트는 서버에 요청을 보내고 서버가 요텅에 대한 결과를 만들어서 응답을 받는 구조

<br>

### 무상태 프로토콜
서버가 클라이언트의 상태를 보존하지 않는다. 서버의 확장성이 높지만 클라이언트가 추가적인 정보를 계속 보내줘야 한다.  
> 중간에 서버가 바뀔 때 이전 상태유지가 되고있다면 클라이언트의 요청을 제대로 이해할 수 없으나 무상태라면 클라이언트가 이전 요청을 모두 지속적으로 하고 있으므로 요청 이해에 문제가 없다.  
> 서버 수평확장에 유리하다.  
모든 요청을 보내기 때문에 데이터양이 많다는 단점이 있다. 

<br>

### 비연결성
TCP/IP는 연결지향적이라 데이터 전송을 하지 않을 때에도 서버자원이 소비된다.  
> http는 요청을 주고받을 때만 연결하여 최소한의 자원만 사용한다.  
TCP/IP연결을 계속 새로 맺어야하기 때문에 3-way handshake시간이 추가되고, html/css/이미지 등 많은 자원이 함께 다운로드되는 단점이 있다.

<br>

### HTTP 메시지
 구조 :   
       
       startline   
         header  
         공백  
         message body  
 시작 라인 
> 요청메시지 : 메소드 요청대상 http버전  
> 응답메시지 : http버전 http상태코드 상태코드의 짧은 설명  

 헤더 : http 전송에 필요한 모든 부가정보(내용, 크기, 압축, 인증, 요청정보, 캐시정보 등등)  
> 요청 : Host: 요청주소  
> 응답 : 응답 컨텐츠 타입, 길이 등등  

메시지 : 실제 전송하는 데이터, 바이트로 표현 가능한 html문서, 이미지 등  

<br>

## HTTP 메소드 종류
- GET : 리소스를 조회하는데 사용하며, 서버에 전달하고 싶은 데이터는 쿼리를 통해 전달한다.  
- POST : 요청데이터를 처리하는데 사용하며, 메시지 바디를 통해 데이터를 전달한다.   
- PUT : 리소스를 대체하는 메소드로, 해당 리소스가 없으면 새로 생성하고 있으면 덮어쓴다.
* post와의 차이 : post는 이소스의 위치를 모르지만 put은 저장할 위치를 알고 있다. 리소스가 있으면 덮어쓰기 때문에 모든 필드를 입력해야 한다.  
- PATCH : 리소스를 부분 변경할 때 사용한다.  
- DELETE : 리소스를 삭제할 때 사용한다.  

<br>

## HTTP 메소드 속성

안전 : 호출해도 리소스를 변경하지 않는 메소드(get)  
멱등 : 한번 호출하든 100번 호출하든 결과가 같다.
> get은 같은 요청을 계속 조회하기 때문에 멱등하다.  
> put은 결과를 덮어쓰기 하므로 같은 요청을 하면 모두 같다.  
> delete는 같은 요청을 계속하면 삭제된 채로 남아있으므로 멱등하다.
> post는 중복이 발생할 수 있으므로 멱등하지 않다.


 캐시 가능 : 응답 결과를 캐시하여 사용하면 다시 리소스를 다운받지 않아도 된다.  

<br>

## HTTP API 설계
- 컬렉션 : 서버가 관리하는 리소스 디렉토리를 컬렉션이라 한다.  
* post : 서버가 데이터를 생성하고 리소스를 식별할 식별자를 추가하여 url을 생성한 후, 응답메시지 location에 /컬렉션/식별자로 전송  
- 스토어 : 클라이언트가 관리하는 리소스 저장소를 스토어라 한다.
* put : 등록할 리소스의 식별자를 알고 클라이언트가 url에 넣어서 /스토어/식별자로 전송  
- http form : get, post만 지원한다.  

<br>

## HTTP 상태코드
클라이언트가 보낸 요청의 처리상태를 응답에서 알려주는 코드  
### 1xx : 요청이 수신되어 처리중

### 2xx: 요청 정상 처리
> 200 OK : 성공  
> 201 Created : 서버가 리소스를 생성  
> 202 Accepted : 요청이 접수되었으나 처리가 완료되지 않음  
> 204 No Content : 서버가 요청을 성공적으로 수행하였으나 응답에 보낼 데이터가 없음(웹문서의 저장기능)  
### 3xx : 요청이 완료되려면 추가행동이 필요(location위치로 redirection)  
> 영구 리다이렉션 : url이 영구적으로 이동되어 원래 url사용할 수 없음  
>> 301 Moved Permanently : 경로가 완전히 이동됨(리다이렉트시 요청 메소드가 get으로 변하고 본문이 제거)  
>> 308 Permanent Redirect : 리다이렉트시 요청 메소드와 본문 유지  


> 일시 리다이렉션 : 일시적 변경  
>> 302 Found : 리다이렉트시 요청 메소드가 get으로 변하고 본문이 제거  
>> 307 Temporary Redirect : 요청메소드와 본문 유지  
>> 303 See Other : 요청에 대한 리소스는 다른 URl에 있기 때문에 GET 메서드를 사용해서 얻어야 한다는 것을 나타냄. 302 코드와 같지만, 303은 리다이렉션 위치를 GET 메서드를 통해 알아야함


> 특수 리다이렉션 : 결과 대신 캐시 사용  

* 일시 리다이렉션(PRG) : post로 요청 후 새로고침시 중복요청 발생하는 문제 발생  
post요청 -> 3xx으로 리다이렉트 -> get으로 데이터 조회하고 응답 200 -> 새로고침해도 get으로 조회하여 중복 발생 문제 해결  

### 4xx : 클라이언트 오류로 서버가 요청을 수행할 수 없음  
> 400 Bad Request : 요청구문, 메시지 오류  
> 401 Unauthorized : 클라이언트가 인증되지 않음  
> 403 Forbidden : 요청을 이해했지만 승인 거부, 접근 권한 불가  
> 404 Not Found : url찾을 수 없음  

### 5xx : 서버 내부 오류로 정상처리를 하지 못함  
> 500 : 서버 내부문제  
> 503 service unvailable : 서버의 일시적 과부하또는 예정된 작업으로 서비스를 잠시 처리할 수 없음  

<br>

## HTTP 헤더

### 일반 헤더 
- body : 메시지 본문을 통해 표현, 요청이나 응답에서 전달할 실 데이터로
> 표현헤더 + 메시지 본문 으로 데이터를 전달  
> content-Type : 표현 데이터의 형식(text/html, application/json, image/png)  
> content-Encoding : 표현 데이터의 압축 방식(gzip, deflate, identity(압축안함))  
> content-Language : 표현데이터의 자연언어(ko, en)  
> content-Length : 표현 데이터의 길이(바이트단위)   
- 협상 : 클라이언트가 선호하는 표현으로 메시지를 달라고 요청하는 것(요청시에만 사용)   
> accept : 클라이언트가 선호하는 미디어타입 전달  
> accept-charset : 클라이언트가 선호하는 문자인코딩  
> accept-encoding : 클라이언트가 원하는 압축 인코딩  
> accept-language : 클라이언트가 원하는 자연언어  
- 우선순위 : quality value값이 클수록, 더 구체적일 수록 높은 우선순위  

- 전송방식 
> 단순 전송 : 컨텐츠 길이를 알고 길이를 지정하여 전송  
> 압축 전송 : 압축하여 용량을 줄여서 전송  
> 분할 전송(transfer-encoding) : 나눠서 전송하여 되는대로 보내지기 때문에 빠름, 길이가 얼마나 될지 알 수 없으므로 길이를 지정하여 전송할 수 없음  
> 범위 전송 : 중간에 전송이 끊기면 필요한 범위부터 전송 요청  

- 일반 정보
> from : 유저 에이전트의 이메일 정보  
> referer : 이전 웹페이지의 주소  
> user-agent : 유저에이전트의 어플리케이션 정보  
> server : 요청을 처리하는 원서버의 정보  
> date : 날짜와 시간  

- 특별 정보 
> host : 요청 호스트 정보  
> location : 리다이렉션 요청시 사용  
> allow : 허용가능한 http메소드  
> retry-after : 다음 요청을 하기까지 기다려야 하는 시간  

- 인증 : 클라이언트의 인증 정보를 서버에 전달

* 쿠키 : 클라이언트가 서버에서 받은 쿠키를 저장하고 http요청시 서버로 전달하여 상태를 기억, 모든 요청 정보에 쿠키를 전송    
> set-cookie : 서버에서 클라이언트로 쿠키 전달  
> 생명주기) expires= 만료일이 되면 쿠키 삭제  
max-age= 초단위  
세션쿠키 : 만료날짜를 생략하면 브라우저 종료시 까지만 유지  
영속쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유효  
> 보안) secure : 원래 쿠키는 http/https를 구분하지 않지만 secure가 붙으면 https일 경우에만 전송  
httpOnly : 자바스크립트에서 접근 불가(xss공격 방지)  
samesite : 요청 도메인과 쿠키가 설정된 도메인이 같을 경우에만 쿠키 전송(xsrf 공격 방지)  

+ xss공격 : 자바 스크립트같은 스크립트코드를 삽입하여 의도치않은 기능이 작동하도록 하는 공격이다.  
공격자가 XSS공격을 통해서 쿠키정보 및 세션 ID를 획득할 수 있다. 

+ xsrf공격 : 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격


<br>

### 캐시와 조건부 요청에 관한 헤더
* 캐시  
> 캐시가 없으면 같은 요청을 했을 때 같은 용량의 응답을 매번 해야함
> 캐시를 적용하면 chache-control이라는 헤더정보에서 캐시 유효 시간을 저장하여 전송하고, 또 다시 같은 요청을 했을 때 클라이언트측 캐시에 같은 요청이 있다면 서버에 요청하지 않고 로드함  
> 응답데이터가 변하지 않았지만 캐시 유효시간이 만료되었을 때, 검증헤더와 조건부요청을 사용하여 다시 로드하지 않아도 됨

- 검증헤더  
> last-modified : 데이터가 마지막에 수정된 시간을 헤더에 적어 응답  
> if-modified-since : 캐시 시간 초과 후 수정일 이래로 변경사항이 없다면 304응답으로 헤더정보만 다시 로드(body없음)하여 사용, 있다면 서버에 다시 요청 
- 조건부 요청 헤더 : 조건이 만족하면 200, 만족하지 않으면 304 응답  
> last-modified의 단점 : 1초미만 단위로 캐시 조정 불가, 날짜기반 로직 사용  
> etag : 캐시용 데이터에 임의의 고유 버전이름을 달아서 데이터가 변경되면 버전이름을 바꾸어 해시값으로 관리, etag를 보내어 해시 값이 같으면 유지, 다르면 다시 요청  
> 클라이언트는 단순히 값을 서버에 제공하고 캐시 메커니즘을 모르기때문에 별도로 캐시를 관리할 수 있다.  
- 캐시 제어헤더 
1. cache-control 캐시제어 : 캐시지시어  
> max-age : 유효시간 (초단위)  
> no-cache : 데이터는 캐시해도 되지만 항상 캐시를 사용하기 전에 조건부요청으로 원래서버에 검증하고 사용  
> no-store 데이터에 민감한 정보가 있으므로 저장하면 안됨(최대한 빨리 삭제) 
2. pragma 캐시제어 하위호환 : no-cache지만 http/1.0하위호환
3. expires 캐시유효기간 하위호환 : 캐시만료일을 날짜로 정할 수 있음(초단위가 훨씬 유연), max-age와 expire가 같이 사용되면 expire는 무시된다. 

- 프록시 캐시 : 원 서버로 직접 접근하면 오래 걸리므로 중간에 프록시캐시 서버를 두어 빠르게 응답이 가능하다.
4. 캐시 무효화 : 캐시를 적용하지 않아도 웹브라우저가 임의로 캐시하기도 하는데 이때 캐시지시어로 무효화할 수 있음
 > cache-control: no-cache, no-store, must-revalidate  
 > pragma: no-cache 까지하면 대부분 캐시 무효화  

* must-revalidate : 캐시 만료 후 최초 조회시 원 서버에 검증 -> 원서버에 접근 실패시 오류(504)발생, 캐시 유효시간이 있으면 캐시 사용  
* no-cache __VS__ must-revalidate : no-cache는 순간 네트워크 단절 등의 문제로 원서버에 접근할 수 없다면 캐시서버 설정에 따라 캐시 데이터를 반환 가능(오류를 보내거나 기존의 데이터라도 보내주는 등의 설정)하지만, must-revalidate는 단절된다면 무조건 오류가 발생한다.